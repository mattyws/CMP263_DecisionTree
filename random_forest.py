import collections

import random

import bootstrap
import decision_tree


class RandomForest(object):

    def __init__(self):
        self.trees = []

    def train(self, X, Y, bootstrap_seed=100, num_trees=3, max_depth=3):
        """
        Train the random forest.
        :param X: the data to train
        :param Y: the labels for the data
        :param bootstrap_seed: the seed used to normalize the randomness of the bootstrap generation
        :param num_trees: the number of trees on the florest
        :param max_depth: the max depth of the trees
        :return:
        """
        for i in range(num_trees):
            tree_bootstrap, labels = bootstrap.Bootstrap.make_bootstrap(X, Y, bootstrap_seed)
            tree_bootstrap = bootstrap.Bootstrap.select_columns(tree_bootstrap, bootstrap_seed)
            tree = decision_tree.DecisionTree()
            tree.train(tree_bootstrap, labels, max_depth=max_depth)
            self.trees.append(tree)
            bootstrap_seed+=10
            # tree.print(graphviz=True, filename="tree_{}".format(i))

    def predict(self, data):
        """
        Predict the label on the data. It uses a majority vote between the predictions of the trees.
        :param data: the data to predict the labels
        :return: the classes predicted
        """
        if data is not None and len(data) != 0:
            if data.shape == (1, len(data.columns)):
                # If the data has only one row, just return the consensus from the trees
                predicted_classes = []
                for tree in self.trees:
                    predicted_classes.append(tree.predict(data))
                return self.__majority_voting(predicted_classes)
            else:
                # If has more than one row, do the predicting for all data given
                classes = []
                for index, row in data.iterrows():
                    predicted_classes = []
                    for tree in self.trees:
                        predicted_classes.append(tree.predict(data.iloc[[index]]))
                    classes.append(self.__majority_voting(predicted_classes))
                return classes

    def __majority_voting(self, predictions):
        """
        Do the majority voting process. In case of tie, uses a coin flip for tie breaking
        :param predictions: the predictions from the trees
        :return: the class that had the most vote
        """
        count = collections.Counter(predictions)
        higher_class = None
        higher_class_count = 0
        for key in count.keys():
            if higher_class_count < count[key]:
                higher_class_count = count[key]
                higher_class = key
            elif higher_class_count == count[key]:
                #if a tie happens, flip a coin, if the coin is odd, use the count[key]
                if random.randint(0, 9) % 2 == 1:
                    higher_class_count = count[key]
                    higher_class = key
        return higher_class


    def get_trees_prediction(self, data):
        """
        Return the predictions generated by the trees.
        :param data: the data to predict
        :return: the trees predictions
        """
        if data is not None and len(data) != 0:
            if data.shape == (1, len(data.columns)):
                # If the data has only one row, just return the consensus from the trees
                predicted_classes = []
                for tree in self.trees:
                    predicted_classes.append(tree.predict(data))
                return predicted_classes
            else:
                # If has more than one row, do the predicting for all data given
                classes = []
                for index, row in data.iterrows():
                    predicted_classes = []
                    for tree in self.trees:
                        predicted_classes.append(tree.predict(data))
                    classes.append(predicted_classes)
                return classes

    def print_forest_trees(self, sufix="tree", graphviz=False):
        """
        Print all trees in the forest.
        :param sufix: the sufix used for the file
        :param graphviz: if is printing them using the graphviz library
        :return:
        """
        i = 0
        for tree in self.trees:
            tree.print(graphviz=graphviz, filename=sufix+"_{}".format(i))
            i+=1

